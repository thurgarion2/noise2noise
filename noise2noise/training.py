# AUTOGENERATED! DO NOT EDIT! File to edit: 00_training.ipynb (unless otherwise specified).

__all__ = ['ToFloatImage', 'Noise2NoiseDataset', 'train', 'eval_model', 'plot_losses']

# Cell
import torch
import torch.nn as nn
from tqdm import tqdm
import matplotlib.pyplot as plt
from torch.utils.data import DataLoader, Dataset
from torchvision import transforms
from .helpers import *
from .unet import *

# Cell
class ToFloatImage:

    def __init__(self):
       pass

    def __call__(self, img):
        return to_float_image(img)

# Cell
class Noise2NoiseDataset(Dataset):
    def __init__(self, img_path, transform=None, target_transform=None):

        self.imgs, self.targets = load_images(img_path)
        self.transform = transform
        self.target_transform = target_transform

    def __len__(self):
        return len(self.imgs)

    def __getitem__(self, idx):
        image, target = self.imgs[idx], self.targets[idx]
        if self.transform:
            image = self.transform(image)
        if self.target_transform:
            target = self.target_transform(target)
        return image, target

# Cell
def train(model, train_loader, test_loader, optim, criterion, gradient_steps=1000, samples_steps=100):
    iterator = iter(train_loader)
    train_loss = []
    test_loss = []


    for steps in tqdm(range(gradient_steps)):
        input, target = None, None
        try:
            input, target = iterator.next()
        except StopIteration:
            iterator = iter(train_loader)
            input, target = iterator.next()

        output = model(input)
        loss = criterion(output, target)
        optim.zero_grad()
        loss.backward()
        optim.step()

        if steps%samples_steps==0 and steps>0:
            train_loss.append(eval_model(model, train_loader, criterion))
            test_loss.append(eval_model(model, test_loader, criterion))

    return train_loss, test_loss




def eval_model(model, loader, criterion):
    losses = []
    iterator = iter(loader)
    with torch.no_grad():
        for loop in range(5):
            input, target = iterator.next()
            output = model(input)
            losses.append(criterion(output, target).item())


    return sum(losses)/len(losses)

# Cell
def plot_losses(train_losses, test_losses):
    r = [x+1 for x in range(len(train_losses))]
    plt.plot(r, train_losses,color='green',label='train')
    plt.plot(r, test_losses,color='red',label='test')
    plt.ylabel('mse')
    plt.legend()